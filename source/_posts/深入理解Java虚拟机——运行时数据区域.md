---
title: 深入理解Java虚拟机——运行时数据区域
date: 2017-11-25 15:17:31
tags:
---
## 1. 运行时数据区域

Java 虚拟机在执行java程序过程中会把它所管理的内存划分为若干个不同区域的数据区，根据Java SE7 规范Java虚拟机所管理的内存将包含以下几个运行时数据区域。

 * 程序计数器区
 * 虚拟机栈
 * 本地方法栈
 * Java堆
 * 方法区
 
### 1.1 程序计数器

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行字节码的行号指示器。解释器工作时通过改变这个计数器的值来选取下一条要执行的字节指令。每条线程都有一个独立的程序计数器，该内存为线程私有内存。
<!-- more -->
### 1.2 Java虚拟机栈

Java 虚拟机栈也是线程私有的, 它的生命周期与线程相同。虚拟机栈是Java方法执行的内存模型：每个方法会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法的执行到完成的过程，就对应一个栈帧在虚拟机栈中的入栈和出栈过程。

平时大家常说的栈大多数时候就是指的这里的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。

局部变量表存放了编译期可知的各种基本的数据类型、对象引用和returnAddress类型（指向一条字节码指令的地址）。当进入一个方法时，该方法需要在帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变空间的大小。

如果线程请求栈深度过大将抛出Stack Overflow异常，如果无法申请到可用内存就会抛出OutOfMemoryError异常。

### 1.3 本地方法栈

本地方法栈和虚拟机栈作用非常类似，区别在于虚拟机栈是为Java方法服务，本地方法栈是为Native方法服务。

### 1.4 Java 堆

Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存的唯一目的就是存放对象实例。Java 堆是垃圾收集器管理的主要区域，由于现代的收集器基本都采用了分代收集算法，所以Java堆还可以细分为：Eden空间、From Survivor 空间、 To Survivor 空间等。当堆无法再扩展时会抛出OutOfMemoryError异常。

### 1.5 方法区

方法区与Java堆一样，是各个线程共享的区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据。通常人们称这块区域为“永久代(Permanent Generation)”，但并非数据进入该区域就永久存储，只是回收条件较为苛刻。

### 1.6 运行时常量池

该区域是方法区的一部分，用于存储编译期生产的各种字面量和符号，运行时常量池局部动态性，即运行期间允许将新常量放入池中（String类的intern()方法）。

### 1.7 直接内存

直接内存并不是虚拟机运行时数据区的一部分。JDK 1.4中引入了NIO类，引入了一种基于Channel与Buffer的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样避免了Java堆与Native堆来回复制数据。



### 1.8. 其他知识点

建立对象是为了使用对象，Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中并没有规定按照什么方式去访问具体对象，目前主流的访问方式有句柄和直接指针两种。

* 如果使用句柄，那么Java堆中将会划分出一块内存来作为句柄池，reference中储存的就是对象的句柄地址，而该句柄中就包含了对象的实例数据与类型数据各自的具体地址信息。
* 直接指针访问，那么Java 对象中就必须考虑如何访问类型数据的相关信息，而reference直接指向对象。

这两种方式各有千秋，句柄方式最大好处是reference中存储的是稳定的句柄地址，对象移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。 而直接指针方式最大好处就是快，目前Sun HotSpot就是使用直接指针方式。