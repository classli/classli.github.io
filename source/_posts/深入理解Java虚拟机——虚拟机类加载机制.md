---
title: 深入理解Java虚拟机——虚拟机类加载机制
date: 2018-01-07 13:58:47
tags:
---
虚拟机把class文件加载到内存，会对数据进行校验、解析和初始化，最终形成可用的Java类。Java中类型的加载、链接和初始化都是在程序运行期间完成的。

### 类加载时机

类从加载到内存，到卸载出内存为止，它经历的过程包括：加载、验证、准备、解析、初始化、使用、卸载。

类的解析有可能在初始化后面(动态绑定)，初始化只发生在下面5个场景：
<!-- more -->
* 使用new、读取设置静态字段(被final修饰的除外，被final修饰的静态字段在编译时就将改字段的值放入了调用类的常量池中)、以及调用一个类的静态方法。
* 反射调用时
* 初始化一个类时，如果其父类还没初始化，则先初始化父类。
* 虚拟机启动时，用户指定的执行主类（包含main方法的那个类）。
* 使用JDK1.7的动态语言时，如果一个java.lang.invoke.MethodHandle实例最后解析结果为REF\_getStatic、REF\_putStatic、REF_invokeStatic的方法句柄、并且这个方法句柄所对应的类还没初始化、则需先初始化。

### 加载

加载阶段主要完成下面三件事情：

* 通过全限定类名获取此类的二进制字节流。
* 将字节流中的静态存储结构转化为方法区的运行时数据结构。
* 生成这个类的java.lang.Class对象，作为方法区这个类的访问入口。

加载阶段完成之后，二进制字节流就按虚拟机所需格式存储在方法区之中。然后实例化一个java.lang.Class对象。加载和链接是交叉进行的，加载阶段还未完成链接就已开始。

### 验证

1. 文件格式验证。验证字节流是否符合Class文件格式规范，只有通过了这个阶段的验证后，字节流才会进入内存方法区中存储，后面的验证则全部基于方法区的存储结构进行的，不在直接操作字节码。
2. 元数据验证。对字节码描述的信息进行语义分析，保证信息符合Java规范，主要是对类的元数据进行语义校验。
3. 字节码验证。主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段主要是对类的方法体进行校验分析。
4. 符号引用验证。这个阶段发生在虚拟机将符号引用转化为直接引用的时候。符号引用验证可以看做是对类自身以外的信息(常量池中的各种符号引用)进行匹配性校验。

### 准备

准备阶段是正式为类变量分配内存并设置类变量初始化的阶段，这些类变量都将在方法区中进行分配。这里只是类变量(被static修饰的变量)，而不是实例变量，实例变量是随着对象的实例化而在Java堆中分配。如果一个变量被定义为static类型，准备阶段只是初始化该变量为数据类型的零值。如：

public static int a = 123;

该阶段a只会被初始化为0，而不是123。在初始化阶段指令编译后a才会被赋值为123，但是如果用final修饰了a，那么在准备阶段就会初始化为123。

### 解析

解析阶段就是将常量池内的符号引用替换为直接引用。这里的符号引用指的是以一组符号(任何形式的字面量)描述所以引用的目标；而直接引用是以直接指向目标的指针、相对偏移量或句柄。

### 初始化

初始化是类加载的最后一个阶段，这个阶段才开始执行类中的Java代码。这个阶段会按照代码要求去初始化变量和其他资源，也可以说是执行类构造器\<clinit>()方法的过程。

\<clinit>()方法是编译器自动收集类中所有变量的赋值动作和静态语句块中的语句合并而成。收集顺序与源文件中出现顺序相同，所以静态块里只能访问在静态块之前定义变量，定义在它之后的变量，静态块只能对其赋值，但不能访问该变量。

\<clinit>()与类的构造方法(\<init>())不同，它不需要显示地调用父类的构造器，虚拟机会保证在调用子类构造器之前，父类的构造器已经执行完毕。

\<clinit>()不是必须的，当没有静态块和赋值操作时，则不会产生。接口中的\<clinit>()不会先执行父类的\<clinit>()，而是在父类变量使用时才执行。

虚拟机会保证\<clinit>()多线程的同步，只有一个线程会执行其他线程阻塞，同一个类加载器一个类只会被初始化一次。

### 类加载器

对应任意一个类，都需要由加载它的类加载器和类本身共同确立在Java虚拟机中的唯一性。类加载器大致分为以下三种：

* 启动类加载器(Bootstrap ClassLoader)：由C++语音实现，用于加载\< JAVA_HOME>\lib目录中的类库到虚拟机内存中。启动类加载器无法被Java程序直接引用。
* 扩展类加载器(Extension ClassLoader)：负责加载\< JAVA_HOME>\lib\ext目录中的类库，开发者可以直接使用扩展类加载器。
* 应用程序类加载器(Application ClassLoader)：这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，一般也称为系统类加载器，负责加载用户类路径上所指定的类库。开发者可直接使用该加载器，一般是默认的类加载器。

类加载器遵循双亲委派模式，并通过组合的方式实现了父子关系。双亲委派模式就是优先由父加载器处理，父类加载器不能处理在交由子加载器处理。这种模式可以保证一些基础类的唯一性。

Java官方推荐用户把自己的加载类逻辑写到findClass()中，这样可以遵循双亲委派模式，如果想破坏这种模式可以覆写loadClass()。

### 其他知识点

对于非数组类的加载通过类加载器完成，而对于数组而言，数组类本身不是通过类加载器创建，而是由Java虚拟机直接创建，但数据组的元素类型最终还是要靠类加载器创建。

OSGi结构中，每个bundle都有自己的类加载器，当更换bundle时，就把bundle连同类加载器一起换掉实现热替换。

OSGi下类加载器不再是双亲委派模式中的树状结构，而是复杂的网状结构。OSGi按下面顺序加载类：

* 将以java.*开头的类委派给父类加载器加载。
* 否则，将委派列表名单内的类委派给父类加载器加载。
* 否则，将import列表中的类委派给Export这个类的bundle的类加载器加载。
* 否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。
* 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。
* 否则，查找Dynamic Import列表的Bundle，委派给对应的Bundle的类加载器加载。
* 否则，类查找失败。

上面只有开头两点符号双亲委派模式，其余的类查找都是平级加载器进行的。