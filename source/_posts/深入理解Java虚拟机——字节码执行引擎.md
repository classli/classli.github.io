---
title: 深入理解Java虚拟机——字节码执行引擎
date: 2018-01-14 13:40:18
tags:
---
每个方法从调用开始至执行完成，都对应着一个栈帧在虚拟机栈的入栈到出栈过程。每个栈帧都包含局部变量表、操作数栈、动态连接、方法返回地址和一些额外信息。在编译代码时栈帧内容就已经确定。

### 局部变量表

局部变量表示一组变量存储空间，用于存储方法参数和方法内部的局部变量。局部变量表的容量以变量槽（Slot）为最小单位，通常一个Slot占用32位长度的内存空间。如果执行的是实例方法（非static的方法），那么局部变量表中的第0位索引的Slot默认就是用于传递方法所属对象实例的引用，其余参数按照参数表顺序排列，参数表完毕后再根据方法体内部定义的变量顺序和作用域分配其余Slot。
<!-- more -->
还有一点需注意，类变量有两次赋初始值的过程，一次在准备阶段，一次在初始化阶段，因此即使没给类变量赋值，类变量也可使用。但是局部变量如果不赋初值是不能使用的。

### 操作数栈

操作数栈是一个后入先出栈，同局部变量表一样，操作数栈的最大深度在也在编译的时候就写入到Code属性的max_stacks数据项中。操作数栈中每个元素都可以是任意的Java数据类型。

在方法开始执行的时候，这个方法的操作数栈是空的，执行过程中会有各种字节码指令往操作数栈中写入或提取。如算数运算或者方法调用传参。

### 返回地址

当一个方法开始执行，只有两种方式可以退出这个方法，一是遇到返回指令，另一个是遇到异常。方法的退出过程实际就是当前栈出栈，退出时的操作有：恢复上一层方法的局部变量表和操作数栈，把返回值压入调用者的操作数栈中，调整PC计数器的值指向方法调用指令后面的一条指令等。

### 方法调用

方法调用并不等同于方法执行，方法调用阶段的任务就是确定调用方法的版本（即调用的哪一个方法），由于Java在编译过程中并没有链接的步骤，一切方法在Class文件里只是符文引用。需要在类加载期间甚至是运行期间才能确定目标方法的直接引用（内存布局中的入口地址）。

#### 解析

在类加载的解析阶段，会对部分符号引用转化为直接引用，这个的前提是调用的方法在编译期可知且运行期不可变。主要包括静态方法和私有方法（这两种方法不能被重写）。

Java虚拟机提供5条方法调用字节指令。

* invokestatic 调用静态方法
* invokespecial 调用实例构造器<init>方法，私有方法和父类方法
* invokevirtual 调用虚方法
* invokeinterface 调用接口方法
* invokedynamic 运行时动态解析出调用点限定符所引用方法，然后再执行该方法。

invokestatic和invokespecial调用的方法，在解析阶段就可将符号引用转化为直接引用，这些方法称为非虚方法，与之对应的称为虚方法（除final方法外，final方法用invokevirtual调用）。

#### 分派--静态分派

	public abstract class Human {
	
	}
	
	public class Man extends Human{

	}
	
	Human man = new Man();

上面的Human称为变量的静态类型， Man称为变量的实际类型。变量的静态类型不会变化，在编译期间就可确定；实际类型在运行期才可确定。在编译阶段Javac编译器会根据参数的静态类型决定使用哪个重载版本。

所有依赖静态类型来决定方法执行版本的分派称为静态分派。典型场景就是方法重载。

#### 分派--动态分派

对于方法的重写，分派依赖的就是变量的实际类型。invokevirtual指令执行的第一步就是在运行期间确定接收者的实际类型。我们把在运行期间根据实际类型确定方法执行版本的分派称为动态分派。虚拟机会在方法区中建立一个虚方法表，来代替元素查找以提高性能。虚方法表中存放着各个方法的实际入口地址。如果子类重写父类的方法，子类方法表中的地址就会替换为指向子类实现版本的入口地址。


#### 分派--单分派与多分派
方法的接收者与方法的参数统称为方法的宗量。单分派就是根据一个宗量对目标方法进行选择，多分派就是根据多个宗量对目标方法进行选择。

### 基于栈与基于寄存器的指令集

基于栈的指令集在执行过程中是通过出栈和入栈对数据进行转移操作，类似于数据结构中通过栈来实现一个表达式计算的方式。而基于寄存器的指令集则是直接对寄存器的赋值操作完成数据转移（Android的dalvik虚拟机是寄存器模式）。

基于栈的指令集不需要考虑硬件性，移植性强，代码更加经凑，但指令数量一般比寄存器架构多。而基于寄存器的指令集，执行速度更快。

